# 【进阶第14期】正则表达式入门
[TOC]


## 前言
---
### 正则表达式功能：验证、查找、替换
1.`验证`字符串是否符合指定特征，比如验证是否是合法的邮件地址。**Validation**
2. 用来`查找`字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便。**Match/find**
3. 用来`替换`，比普通的替换更强大。**Replace**

## 正则表达式规则
---
### 字符分类
#### 普通字符
字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是"普通字符"。

#### 简单的转义字符

表达式 | 可匹配
-- | -- |--
 \r, \n| 代表回车和换行符
 \t    | 制表符
 \\    | 代表 "\" 本身

还有其他元字符， 在`前面加 "\" 后`，就代表该符号本身

 表达式 | 可匹配
 --     |  --
 `\^`    |  匹配 ^ 符号本身
 `\$`  |  匹配 $ 符号本身
 `\.`     |  匹配小数点（.）本身

`举例1：` 表达式 "\$d"，在匹配字符串 "abc$de" 时 ，匹配结果是：成功；匹配到的内容是："$d"；匹配到的位置是：开始于3，结束于5。

#### 元字符
分类：
* 单个字符集、自定义字符集合
* 字符次数限定符
* 边界界定符
* 匹配引用

##### 字符集
**匹配 '多种字符' 其中的任意一个字符**

 表达式 | 可匹配
 --     |  --
 \d    | 任意一个数字，0~9 中的任意一个
 \w   | 任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9, \_ 中任意一个
 \s   | 包括空格、制表符、换页符等空白字符的其中任意一个
 .    |  小数点可以匹配除了换行符（\n）以外的任意一个字符

`举例1：` 表达式 "\d\d "，在匹配 "abc123" 时 ，匹配的结果是：成功；匹配到的内容是："12"；匹配到的位置是：开始于3，结束于5。

##### 自定义字符集
**自定义能够匹配 '多种字符' 的任意一个字符**

 表达式 | 可匹配
 --    |  --
 [ab5@] | 匹配 "a" 或 "b" 或 "5" 或 "@"
 [^abc] | 匹配 "a","b","c" 之外的任意一个字符
 [f-k] | 匹配 "f"~"k" 之间的任意一个字母
 [^A-F0-3]|匹配 "A"~"F","0"~"3" 之外的任意一个字符
`举例1：`表达式 " [bcd] [bcd] " 匹配 "abc123" 时 ，匹配的结果是：成功；匹配到内容是："bc"；匹配的位置是：开始于1，结束于3。
`举例2：`表达式 " [^abc] " 匹配 "abc123" 时 ，匹配的结果是：成功；匹配到的内容是："1"；匹配到的位置是：开始于3，结束于4。

##### 次数限定符
**修饰匹配次数的特殊符号**
使用方法是："次数修饰"放在"被修饰的表达式"后边。

 表达式|作用
--|--
{n}|表达式重复n次，比如：  "\w{2}" 相当于 "\w\w" ；  "a{5}" 相当于 "aaaaa"
{m,n}|表达式至少重复m次，最多重复n次，比如：  "ba{1,3}"可以匹配 "ba"或"baa"或"baaa"
 {m,} | 表达式至少重复m次，比如：  "\w\d{2,}"可以匹配 "a12","\_456","M12344"...
 ? | 出现零次或一次，最多一次，相当于 {0,1}，比如：  "a[cd]?"可以匹配 "a","ac","ad"
 + | 表达式至少出现1次，相当于 {1,}，比如：  "a+b"可以匹配 "ab","aab","aaab"...
 \* | 出现任意次（零次、一次、多次），相当于 {0,}，比如：  "\^*b"可以匹配 "b","^^^b"...

`举例1：` 表达式 " \d + \. ? \d * " 在匹配 "It costs $12.5" 时 ，匹配的结果是：成功；匹配到的内容是："12.5"；匹配到的位置是：开始于10，结束于14。
`举例2：` 表达式 " go {2,8} gle " 在匹配 "Ads by goooooogle" 时 ，匹配的结果是：成功；匹配到的内容是："goooooogle"；匹配到的位置是：开始于7，结束于17。

##### 边界（位置）界定符
其他一些代表抽象意义的特殊符号

表达式|作用
 -- |--
 ^  | 与字符串开始的地方匹配，不匹配任何字符
 $ | 与字符串结束的地方匹配，不匹配任何字符
 \b | 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符
\1 \2 ..\7 |标识一个八进制转义码或反向引用。如果 \n前面至少有n个捕获子表达式，那么 _n_ 是反向引用。否则，如果n是八进制数 (0-7)，那么n是八进制转义码。

`举例1：` 表达式 `^aaa` 在匹配 "xxxaaa xxx" 时 ，匹配结果是：失败。因为 "^" 要求与字符串开始的地方匹配，因此，只有当 "aaa" 位于字符串的开头的时候，"^aaa" 才能匹配， 比如："aaaxxxxxx" 。
`举例2：` 表达式 `aaa$` 在匹配 "xxx aaa xxx" 时 ，匹配结果是：失败。因为 "$" 要求与字符串结束的地方匹配，因此，只有当 "aaa" 位于字符串的结尾的时候，"aaa$" 才能匹配， 比如："xxx xxx aaa" 。
`举例3：` 表达式 " `.\b.`" 在匹配 "@@@abc" 时 ，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4。

进一步说明：
```
"\b" 与 "^" 和 "$" 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 "\w" 范围，另一边是 非"\w" 的范围。
```

`举例4：` 表达式 " \b end \b " 在匹配 "weekend,endfor,end" 时 ，匹配结果是：成功；匹配到的内容是："end"；匹配到的位置是：开始于15，结束于18。


一些符号可以影响表达式内部的子表达式之间的关系：

 表达式|作用
--| --
 竖线 | 左右两边表达式之间 "或" 关系，匹配左边或者右边
 ( ) | (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰  (2). `取匹配结果`的时候，括号中的表达式匹配到的内容可以被单独得到

`举例5：` 表达式 " Tom | Jack " 在匹配字符串 "I'm Tom, he is Jack" 时 ，匹配结果是：成功；匹配到的内容是："Tom"；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是："Jack"；匹配到的位置时：开始于15，结束于19。

`举例6：` 表达式 " ( go \s * ) + " 在匹配 "Let's go go go!" 时 ，匹配结果是：成功；匹配到内容是："go go go"；匹配到的位置是：开始于6，结束于14。

`举例7：` 表达式 " ￥ ( \d + \. ? \d * ) " 在匹配 "＄10.9,￥20.5" 时 ，匹配的结果是：成功；匹配到的内容是："￥20.5"；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是："20.5"。

##### 字符集以外
 表达式 | 可匹配
 -- | --
 \S | 匹配所有非空白字符（"\s" 可匹配各个空白字符）
 \D | 匹配所有的非数字字符
 \W | 匹配所有的字母、数字、下划线以外的字符
 \B | 匹配非单词边界，即左右两边都是 "\w" 范围或者左右两边都不是 "\w" 范围时的字符缝隙
[^x] | 匹配非x字符
[^aeiou] | 匹配非a、e、i、o、u字符

##### 引用匹配到的字符串

符号|释义
--|--
 $1、$2、...、$99 | 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 |
 $& | 与 regexp 相匹配的子串。 |
 $` | 位于匹配子串左侧的文本。 |
 $' | 位于匹配子串右侧的文本。 |
 `$$` | 直接量符号。 |

### 高级规则--匹配次数中的贪婪与非贪婪
---
#### 贪婪模式
在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如："{m,n}", "{m,}", "?", "\*", "+"，具体匹配的次数随被匹配的字符串而定。这种 重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配 。比如，`针对文本 "dxxxdxxxd"`，举例如下：

 表达式 | 匹配结果
 -- | --
 (d)(\w+) | "\w+" 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"
(d)(\w+)(d) | "\w+" 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "\w+" 也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功，"\w+" 可以 "让出" 它本来能够匹配的最后一个 "d"

由此可见，"\w+" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 "\*" 和 "{m,n}" 的表达式都是尽可能地多匹配， 带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配 "。这种匹配原则就叫作 `贪婪模式`。

#### 非贪婪模式（最小匹配）
在修饰匹配次数的特殊符号后再加上一个 "?" 号 ，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 "不匹配"。这种匹配原则叫作 "非贪婪" 模式，也叫作 "勉强" 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 "dxxxdxxxd" 举例：

 表达式 | 匹配结果
 --  |  --
(d)(\w+?)  |"\w+?" 将尽可能少的匹配第一个 "d" 之后的字符，结果是："\w+?" 只匹配了一个 "x"
(d) (\w+?)(d)  | 为了让整个表达式匹配成功，"\w+?" 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，从而使整个表达式匹配成功。因此，结果是："\w+?" 匹配 "xxx"


```
`举例1：`
表达式"<td> ( . * ) </td> " 与字符串 "<td><p>aa</p></td> <td><p>bb</p></td>" 匹配时 ，匹配的结果是：成功；匹配到的内容是 "<td><p>aa</p></td> <td><p>bb</p></td>" 整个字符串， 表达式中的 "</td>" 将与字符串中最后一个 "</td>" 匹配。 
`举例2：` 相比之下，表达式 " <td> ( . * ? ) </td> " 匹配举例1中同样的字符串时 ，将只得到 "<td><p>aa</p></td>"， 再次匹配下一个时，可以得到第二个 "<td><p>bb</p></td>"。
````
（2）、反向引用 \1, \2...
  表达式在匹配时，表达式引擎会将小括号 "( )" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 " <td> ( . * ? ) </td> "。

 其实，"小括号包含的表达式所匹配到的字符串" 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "\" 加上一个数字。"\1" 引用第1对括号内匹配到的字符串，"\2" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号。

举例如下：
`举例1：`表达式 " ( ' | " ) ( . * ? ) ( \1 ) " 在匹配 " 'Hello', "World" " 时 ，匹配结果是：成功；匹配到的内容是：" 'Hello' "。再次匹配下一个时，可以匹配到 " "World" "。
`举例2：`表达式 " ( \w ) \1 {4,} " 在匹配 "aa bbbb abcdefg ccccc 111121111 999999999" 时 ，匹配结果是：成功；匹配到的内容是 "ccccc"。再次匹配下一个时，将得到 999999999。这个表达式要求 "\w" 范围的字符至少重复5次，   注意与 "\w{5,}" 之间的区别 。


 举例3：表达式 " < ( \w + ) \s * ( \w + ( = ( ' | " ) . * ? \4 ) ? \s * ) * > . * ? </ \1 > " 在匹配 "<td id='td1' style="bgcolor:white"></td>" 时 ，匹配结果是成功。如果 "<td>" 与 "</td>" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。


(3)、 预搜索，不匹配；反向预搜索，不匹配
  前面的章节中，我讲到了几个代表抽象意义的特殊符号："^"，"$"，"\b"。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 "字符串的两头" 或者 "字符之间的缝隙" 附加了一个条件。

理解到这个概念以后，本节将继续介绍另外一种对 "两头" 或者 "缝隙" 附加条件的，更加灵活的表示方法。

    正向预搜索："(?=xxxxx)"，"(?!xxxxx)"

格式："(?=xxxxx)"，在被匹配的字符串中，它对所处的 "缝隙" 或者 "两头" 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 "\b"，本身不匹配任何字符。"\b" 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。
举例1：表达式 " Windows  (?= NT | XP ) " 在匹配 "Windows 98, Windows NT, Windows 2000" 时 ，将只匹配 "Windows NT" 中的 "Windows "，其他的 "Windows " 字样则不被匹配。
 举例2：表达式 " ( \w ) ( (?= \1 \1 \1 ) ( \1 ) ) + " 在匹配字符串 "aaa ffffff 999999999" 时 ，将可以匹配6个"f"的前4个，可以匹配9个"9"的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当然，这个表达式可以不这样写，在此的目的是作为演示之用。

    格式："(?!xxxxx)"，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。



 举例3：表达式 " ( (?! \b stop \b ) . ) + " 在匹配 "fdjka ljfdl stop fjdsla fdj" 时 ，将从头一直匹配到 "stop" 之前的位置，如果字符串中没有 "stop"，则匹配整个字符串。



举例4：表达式 " do (?! \w ) " 在匹配字符串 "done, do, dog" 时 ，只能匹配 "do"。在本条举例中，"do" 后边使用 "(?!\w)" 和使用 "\b" 效果是一样的。

反向预搜索："(?<=xxxxx)"，"(?<!xxxxx)"

    这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 "左侧"，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 "正向预搜索" 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。

    举例5：表达式 " (?<= \d {4} ) \d + (?= \d {4} ) " 在匹配 "1234567890123456" 时，将匹配除了前4个数字和后4个数字之外的中间8个数字。由于 JScript.RegExp 不支持反向预搜索，因此，本条举例不能够进行演示。很多其他的引擎可以支持反向预搜索，比如：Java 1.4 以上的 java.util.regex 包，.NET 中System.Text.RegularExpressions 命名空间，以及本站推荐的 最简单易用的 DEELX 正则引擎 。


3 其他通用规则
还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。

（1） 表达式中，可以使用 "\xXX" 和 "\uXXXX" 表示一个字符（"X" 表示一个十六进制数）

 形式 | 字符范围
 --|--
 \xXX | 编号在 0 ~ 255 范围的字符，比如： 空格可以使用 "\x20" 表示
 \uXXXX | 任何字符可以使用 "\u" 再加上其编号的4位十六进制数表示，比如： "\u4E2D"




3.2 在表达式中有特殊意义，需要添加 "\" 才能匹配该字符本身的字符汇总

 字符|说明
 --|--
 ^ | 匹配输入字符串的开始位置。要匹配 "^" 字符本身，请使用 "\^"
 \$  | 匹配输入字符串的结尾位置。要匹配 "$" 字符本身，请使用 "\$"
 ( ) | 标记一个`子表达式`的开始和结束位置。要匹配小括号，请使用 "\(" 和 "\)"
 [ ] | 用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 "\[" 和 "\]"
 { } | 修饰匹配次数的符号。要匹配大括号，请使用 "\{" 和 "\}"
 . | 匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 "\."
 ? | 修饰匹配次数为 0 次或 1 次。要匹配 "?" 字符本身，请使用 "\?"
 + | 修饰匹配次数为至少 1 次。要匹配 "+" 字符本身，请使用 "\+"
 \* | 修饰匹配次数为 0 次或任意次。要匹配 "\*" 字符本身，请使用 "\*"
 竖线 |左右两边表达式之间 "或" 关系。匹配 `竖线` 本身，请使用 `竖线`


**如何修改子匹配**


```
var s1 = "foo-style-css";
s1 = s1.replace(/-(\w)/g, function(all, letter){
 console.log(arguments)
 return letter.toUpperCase();
});
```



| compare  |  des |
| ------------ | ------------ |
|(?=X)   |  匹配任何其后紧接指定字符串 n 的字符串 |
|(?:X)   | `(X)`和`(?:X)`，前者是捕获分组，后者不获  |

```
/(\w)(?=\1{3,})/.test("AAAAAAAA") //true
/(\w)(?=\1{3,})/.test("AAAB") //false


var m = "abcabc".match(/(?:a)(b)(c)/)
//结果 ["abc", "b", "c"]
// m[0] 是/(?:a)(b)(c)/匹配到的整个字符串，这里包括了a
// m[1] 是捕获组1，即(b)匹配的子字符串substring or sub sequence
// m[2] 是捕获组2，即(c)匹配到的
```


### 练习
- [闯关模式练习正则表达式，完成一个个正则匹配的测验](http://regex.alf.nu)
- [通过实际练习掌握正则表达式](http://regexone.com/) 
- [正则挑战，有不同难度，很丰富](https://regexcrossword.com/)
- [正则挑战，完成正则匹配要求](http://callumacrae.github.io/regex-tuesday/)
