<!doctype html>
<html lang="en" data-color-mode="dark">
<head>
<meta charset="utf-8">
<title>
## 前言

每个 JavaScript 函数实际上都是一个 `Function` 对象。运行 `(function(){}).constructor  &#x26;  js-function cheatsheet &#x26;  Quick Reference</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta description="，为开发人员分享快速参考备忘单。">
<meta keywords="js-function,reference,Quick,Reference,cheatsheet,cheat,sheet">
<link rel="icon" href="data:image/svg+xml,%3Csvg%20viewBox%3D%220%200%2024%2024%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%221em%22%20width%3D%221em%22%3E%20%3Cpath%20d%3D%22m21.66%2010.44-.98%204.18c-.84%203.61-2.5%205.07-5.62%204.77-.5-.04-1.04-.13-1.62-.27l-1.68-.4c-4.17-.99-5.46-3.05-4.48-7.23l.98-4.19c.2-.85.44-1.59.74-2.2%201.17-2.42%203.16-3.07%206.5-2.28l1.67.39c4.19.98%205.47%203.05%204.49%207.23Z%22%20fill%3D%22%23c9d1d9%22%2F%3E%20%3Cpath%20d%3D%22M15.06%2019.39c-.62.42-1.4.77-2.35%201.08l-1.58.52c-3.97%201.28-6.06.21-7.35-3.76L2.5%2013.28c-1.28-3.97-.22-6.07%203.75-7.35l1.58-.52c.41-.13.8-.24%201.17-.31-.3.61-.54%201.35-.74%202.2l-.98%204.19c-.98%204.18.31%206.24%204.48%207.23l1.68.4c.58.14%201.12.23%201.62.27Zm2.43-8.88c-.06%200-.12-.01-.19-.02l-4.85-1.23a.75.75%200%200%201%20.37-1.45l4.85%201.23a.748.748%200%200%201-.18%201.47Z%22%20fill%3D%22%23228e6c%22%20%2F%3E%20%3Cpath%20d%3D%22M14.56%2013.89c-.06%200-.12-.01-.19-.02l-2.91-.74a.75.75%200%200%201%20.37-1.45l2.91.74c.4.1.64.51.54.91-.08.34-.38.56-.72.56Z%22%20fill%3D%22%23228e6c%22%20%2F%3E%20%3C%2Fsvg%3E" type="image/svg+xml">
<link rel="stylesheet" href="../style/style.css">
<link rel="stylesheet" href="../style/katex.css">
</head>
<body><nav class="header-nav"><div class="max-container"><a href="../index.html" class="logo"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" height="1em" width="1em">
  <path d="m21.66 10.44-.98 4.18c-.84 3.61-2.5 5.07-5.62 4.77-.5-.04-1.04-.13-1.62-.27l-1.68-.4c-4.17-.99-5.46-3.05-4.48-7.23l.98-4.19c.2-.85.44-1.59.74-2.2 1.17-2.42 3.16-3.07 6.5-2.28l1.67.39c4.19.98 5.47 3.05 4.49 7.23Z" fill="#c9d1d9"></path>
  <path d="M15.06 19.39c-.62.42-1.4.77-2.35 1.08l-1.58.52c-3.97 1.28-6.06.21-7.35-3.76L2.5 13.28c-1.28-3.97-.22-6.07 3.75-7.35l1.58-.52c.41-.13.8-.24 1.17-.31-.3.61-.54 1.35-.74 2.2l-.98 4.19c-.98 4.18.31 6.24 4.48 7.23l1.68.4c.58.14 1.12.23 1.62.27Zm2.43-8.88c-.06 0-.12-.01-.19-.02l-4.85-1.23a.75.75 0 0 1 .37-1.45l4.85 1.23a.748.748 0 0 1-.18 1.47Z" fill="#228e6c"></path>
  <path d="M14.56 13.89c-.06 0-.12-.01-.19-.02l-2.91-.74a.75.75 0 0 1 .37-1.45l2.91.74c.4.1.64.51.54.91-.08.34-.38.56-.72.56Z" fill="#228e6c"></path>
</svg>
<span class="title">Quick Reference</span></a><div class="menu"><a href="javascript:void(0);" class="searchbtn" id="searchbtn"><svg xmlns="http://www.w3.org/2000/svg" height="1em" width="1em" viewBox="0 0 18 18">
  <path fill="currentColor" d="M17.71,16.29 L14.31,12.9 C15.4069846,11.5024547 16.0022094,9.77665502 16,8 C16,3.581722 12.418278,0 8,0 C3.581722,0 0,3.581722 0,8 C0,12.418278 3.581722,16 8,16 C9.77665502,16.0022094 11.5024547,15.4069846 12.9,14.31 L16.29,17.71 C16.4777666,17.8993127 16.7333625,18.0057983 17,18.0057983 C17.2666375,18.0057983 17.5222334,17.8993127 17.71,17.71 C17.8993127,17.5222334 18.0057983,17.2666375 18.0057983,17 C18.0057983,16.7333625 17.8993127,16.4777666 17.71,16.29 Z M2,8 C2,4.6862915 4.6862915,2 8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 Z"></path>
</svg><span>搜索</span><span>⌘K</span></a><a href="https://github.com/jaywcjlove/reference/blob/main/experience/js-function.md" class="" target="__blank"><svg viewBox="0 0 36 36" fill="currentColor" height="1em" width="1em"><path d="m33 6.4-3.7-3.7a1.71 1.71 0 0 0-2.36 0L23.65 6H6a2 2 0 0 0-2 2v22a2 2 0 0 0 2 2h22a2 2 0 0 0 2-2V11.76l3-3a1.67 1.67 0 0 0 0-2.36ZM18.83 20.13l-4.19.93 1-4.15 9.55-9.57 3.23 3.23ZM29.5 9.43 26.27 6.2l1.85-1.85 3.23 3.23Z"></path><path fill="none" d="M0 0h36v36H0z"></path></svg><span>编辑</span></a><button id="darkMode" type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="light" height="1em" width="1em">
  <path d="M6.995 12c0 2.761 2.246 5.007 5.007 5.007s5.007-2.246 5.007-5.007-2.246-5.007-5.007-5.007S6.995 9.239 6.995 12zM11 19h2v3h-2zm0-17h2v3h-2zm-9 9h3v2H2zm17 0h3v2h-3zM5.637 19.778l-1.414-1.414 2.121-2.121 1.414 1.414zM16.242 6.344l2.122-2.122 1.414 1.414-2.122 2.122zM6.344 7.759 4.223 5.637l1.415-1.414 2.12 2.122zm13.434 10.605-1.414 1.414-2.122-2.122 1.414-1.414z"></path>
</svg>
<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" class="dark" height="1em" width="1em">
  <path d="M12 11.807A9.002 9.002 0 0 1 10.049 2a9.942 9.942 0 0 0-5.12 2.735c-3.905 3.905-3.905 10.237 0 14.142 3.906 3.906 10.237 3.905 14.143 0a9.946 9.946 0 0 0 2.735-5.119A9.003 9.003 0 0 1 12 11.807z"></path>
</svg>
</button><script src="../js/dark.js"></script><a href="https://github.com/geek-tim/reference" class="" target="__blank"><svg viewBox="0 0 16 16" fill="currentColor" height="1em" width="1em"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg></a></div></div></nav><div class="wrap h2body-not-exist"><div class="wrap-header h2wrap"><h2 id="前言"><a aria-hidden="true" tabindex="-1" href="#前言"><span class="icon icon-link"></span></a>前言</h2><div class="wrap-body">
<p>每个 JavaScript 函数实际上都是一个 <code>Function</code> 对象。运行 <code>(function(){}).constructor === Function // true</code> 便可以得到这个结论。</p>
</div></div><div class="h2wrap-body"></div></div><div class="wrap h2body-exist"><div class="wrap-header h2wrap"><h2 id="一函数"><a aria-hidden="true" tabindex="-1" href="#一函数"><span class="icon icon-link"></span></a>[一]、函数</h2><div class="wrap-body">
<p><strong>函数的声明</strong></p>
<p>声明函数的存在，包括函数的名字、函数类型以及形参类型。并把这些信息通知编译系统，以便在调用该函数时进行对照检查（例如，函数名是否正确，实参与形参的类型和个数是否一致），它不包括函数体。这种情况下函数和函数定义分开。</p>
<p>JS中不存在函数声明。 因为JS是弱类型语言，声明变量的时候并不能确定变量的类型。</p>
</div></div><div class="h2wrap-body"><div class="wrap h3body-exist"><div class="wrap-header h3wrap"><h3 id="11-函数定义"><a aria-hidden="true" tabindex="-1" href="#11-函数定义"><span class="icon icon-link"></span></a>1.1 函数定义</h3><div class="wrap-body">
<p>对函数功能的确立，包括指定函数名，函数类型(返回值)、形参类型(参数)、函数体等，它是一个完整的、独立的函数单位。</p>
<h4 id="111-声明式"><a aria-hidden="true" tabindex="-1" href="#111-声明式"><span class="icon icon-link"></span></a>1.1.1 声明式</h4>
<p>使用关键字<code>function</code>定义函数。</p>
<pre><code class="code-highlight"><span class="code-line">function func() {
</span><span class="code-line">  // body
</span><span class="code-line">}
</span></code></pre>
<h4 id="112-函数表达式"><a aria-hidden="true" tabindex="-1" href="#112-函数表达式"><span class="icon icon-link"></span></a>1.1.2 函数表达式</h4>
<p>在一个表达式中定义一个函数，可以指定函数名也可以不指定。可以理解为定义一个变量，这个变量是函数对象。函数表达式定义的函数在代码执行的时候才会真正创建。</p>
<pre><code class="code-highlight"><span class="code-line">// # 语法
</span><span class="code-line">const func = function [name]([param1[, param2[, ..., paramN]]]) { statements };
</span><span class="code-line">
</span><span class="code-line">const func = function() {
</span><span class="code-line">  // code
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">
</span><span class="code-line">const func = function func() {
</span><span class="code-line">  // code
</span><span class="code-line">}
</span></code></pre>
<h4 id="113-构造函数-function"><a aria-hidden="true" tabindex="-1" href="#113-构造函数-function"><span class="icon icon-link"></span></a>1.1.3 构造函数 Function</h4>
<p>JS支持使用<code>Function / GeneratorFunction</code>动态创建一个新的Function对象，也就是函数对象。</p>
<pre><code class="code-highlight"><span class="code-line">// # 语法
</span><span class="code-line">new Function ([arg1[, arg2[, ...argN]],] functionBody)
</span><span class="code-line">
</span><span class="code-line">let str = 'return ' + '`Hello ${name}!`';
</span><span class="code-line">let func = new Function('name', str);
</span><span class="code-line">
</span><span class="code-line">func('Jack') // "Hello Jack!"
</span></code></pre>
<p>使用Function构造器生成的Function对象是在函数创建时解析的。这比你使用函数声明或者函数表达式(function)并在你的代码中调用更为低效，因为使用后者创建的函数是跟其他代码一起解析的。所以一般情况下不推荐使用这种方式</p>
</div></div></div><div class="wrap h3body-exist"><div class="wrap-header h3wrap"><h3 id="12-函数类型"><a aria-hidden="true" tabindex="-1" href="#12-函数类型"><span class="icon icon-link"></span></a>1.2 函数类型</h3><div class="wrap-body">
<pre><code class="code-highlight"><span class="code-line">-   Function：普通函数，使用function定义的函数。
</span><span class="code-line">-   Arrow Function：箭头函数，使用=>定义的函数。
</span><span class="code-line">-   Generator Function：使用function*定义的函数。
</span><span class="code-line">-   Async Function：使用async function定义的函数。
</span></code></pre>
<h4 id="121-function"><a aria-hidden="true" tabindex="-1" href="#121-function"><span class="icon icon-link"></span></a>1.2.1 Function</h4>
<p>普通函数，也就是我们常说的函数。</p>
<h4 id="122-arrow-function"><a aria-hidden="true" tabindex="-1" href="#122-arrow-function"><span class="icon icon-link"></span></a>1.2.2 Arrow Function</h4>
<p>箭头函数表达式的语法比函数表达式更短，简洁。箭头函数更适用于那些本来需要匿名函数的地方。</p>
<p>箭头函数的特点</p>
<ul>
<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
</ul>
<h5 id="适用场景"><a aria-hidden="true" tabindex="-1" href="#适用场景"><span class="icon icon-link"></span></a>适用场景</h5>
<pre><code class="code-highlight"><span class="code-line">// 1、简化回调函数
</span><span class="code-line">const arr = ['a', ' b', ' c '];
</span><span class="code-line">
</span><span class="code-line">
</span><span class="code-line">// 正常函数写法
</span><span class="code-line">arr.map(function (str) {
</span><span class="code-line">  return str.trim();
</span><span class="code-line">});
</span><span class="code-line">
</span><span class="code-line">
</span><span class="code-line">// 箭头函数写法
</span><span class="code-line">arr.map(str => str.trim())
</span></code></pre>
<h5 id="不适场景"><a aria-hidden="true" tabindex="-1" href="#不适场景"><span class="icon icon-link"></span></a>不适场景</h5>
<pre><code class="code-highlight"><span class="code-line">// 1. 定义函数方法，且方法内部包含this
</span><span class="code-line">const cat = {
</span><span class="code-line">  lives: 9,
</span><span class="code-line">  jumps: () => { this.lives--; }
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line">
</span><span class="code-line">// 2. 需要动态的this
</span><span class="code-line">const button = document.getElementById('press'); 
</span><span class="code-line">button.addEventListener('click', () => { 
</span><span class="code-line">    this.classList.toggle('on'); 
</span><span class="code-line">});
</span></code></pre>
<ul>
<li>
<ol>
<li>cat.jumps()方法是一个箭头函数，这是错误的。调用cat.jumps()时，如果是普通函数，该方法内部的this指向cat；如果写成上面那样的箭头函数，使得this指向全局对象，因此不会得到预期结果。</li>
</ol>
</li>
<li>
<ol start="2">
<li>点击按钮会报错，因为button的监听函数是一个箭头函数，导致里面的this就是全局对象。如果改成普通函数，this就会动态指向被点击的按钮对象。</li>
</ol>
</li>
</ul>
<h4 id="123-generator-function"><a aria-hidden="true" tabindex="-1" href="#123-generator-function"><span class="icon icon-link"></span></a>1.2.3 Generator Function</h4>
<p>generator函数用来返回generator对象，并且它符合可迭代协议和迭代器协议。</p>
<p>在没有async函数之前，generator函数主要用来异步编程。阮一峰老师的ES6入门对generator有详细的有详细的介绍，这里就不再啰嗦。</p>
<p>co是一个generator流程控制器。在有async函数之前，co和generator是绝佳搭配。co代码小巧精悍，值得学习其中的JS技巧。</p>
<p>co.wrap用来封装generator成Promise对象，使得generator可以像Promise对象一样使用，同时也依然保持generator要完成的功能，也就是generator会依然正常执行。</p>
<h4 id="124-async-function"><a aria-hidden="true" tabindex="-1" href="#124-async-function"><span class="icon icon-link"></span></a>1.2.4 Async Function</h4>
<p>Async函数用来处理异步操作，避免了回调黑洞，让异步代码看起来更human readable。</p>
<p><strong>Async函数的特点</strong></p>
<ul>
<li>调用async函数的时候会异步执行。</li>
<li>在async函数中使用await的时候，会执行完当前代码才会往下继续执行其他代码，实现按照指定顺序执行异步操作。</li>
<li>async函数会返回一个Promise对象。</li>
</ul>
<h5 id="异常处理方案"><a aria-hidden="true" tabindex="-1" href="#异常处理方案"><span class="icon icon-link"></span></a>异常处理方案</h5>
<pre><code class="code-highlight"><span class="code-line">// 1.  **try catch**
</span><span class="code-line">async function fun() {
</span><span class="code-line">  await Promise.reject('error test')
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">async function run() {
</span><span class="code-line">  try {
</span><span class="code-line">    await fun();
</span><span class="code-line">  } catch(e) {
</span><span class="code-line">    console.log(e); // catch error test
</span><span class="code-line">  }
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">run()
</span><span class="code-line">
</span><span class="code-line">// 2. Promise.catch()
</span><span class="code-line">async function fun() {
</span><span class="code-line">  await Promise.reject('error test')
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line">fun()
</span><span class="code-line">.then(v => console.log('success'))
</span><span class="code-line">.catch(e => console.log('catch', e)); // catch error test
</span></code></pre>
</div></div></div><div class="wrap h3body-exist"><div class="wrap-header h3wrap"><h3 id="13-函数的参数arguments"><a aria-hidden="true" tabindex="-1" href="#13-函数的参数arguments"><span class="icon icon-link"></span></a>1.3 函数的参数(arguments)</h3><div class="wrap-body">
<h4 id="131-参数类型"><a aria-hidden="true" tabindex="-1" href="#131-参数类型"><span class="icon icon-link"></span></a>1.3.1 参数类型</h4>
<h5 id="形参"><a aria-hidden="true" tabindex="-1" href="#形参"><span class="icon icon-link"></span></a>形参</h5>
<p>形式参数，是在声明或定义函数的时候在()中使用的参数，目的是用来接收调用该函数时传递的参数。可以把形参理解为一种变量。</p>
<p>形参只有在函数被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。</p>
<h5 id="实参"><a aria-hidden="true" tabindex="-1" href="#实参"><span class="icon icon-link"></span></a>实参</h5>
<p>实际参数，是在调用函数时传递的参数，即传递给被调用函数的值。</p>
<h4 id="132-参数传递"><a aria-hidden="true" tabindex="-1" href="#132-参数传递"><span class="icon icon-link"></span></a>1.3.2 参数传递</h4>
<ul>
<li>值传递：对于基本数据类型来说，形参会拷贝实参的值(参考<a href="https://link.zhihu.com/?target=https%3A//shimo.im/docs/MKnt1hIpFK4rp9ml">JS Data &#x26; Type</a>基本类型)。</li>
<li>引用传递：对于引用类型来说，形参拷贝实参的内存地址(参考<a href="https://link.zhihu.com/?target=https%3A//shimo.im/docs/MKnt1hIpFK4rp9ml">JS Data &#x26; Type</a>引用类型)。</li>
</ul>
</div></div></div><div class="wrap h3body-exist"><div class="wrap-header h3wrap"><h3 id="14-函数调用"><a aria-hidden="true" tabindex="-1" href="#14-函数调用"><span class="icon icon-link"></span></a>1.4 函数调用</h3><div class="wrap-body">
<p>JS有三种函数调用方式：直接调用、apply调用和call调用。</p>
<h4 id="141-直接调用"><a aria-hidden="true" tabindex="-1" href="#141-直接调用"><span class="icon icon-link"></span></a>1.4.1 直接调用</h4>
<p>函数名 + 参数</p>
<pre><code class="code-highlight"><span class="code-line">// 语法
</span><span class="code-line">funcName(arg1, arg2, ..) 
</span></code></pre>
<h4 id="142-call"><a aria-hidden="true" tabindex="-1" href="#142-call"><span class="icon icon-link"></span></a>1.4.2 call</h4>
<pre><code class="code-highlight"><span class="code-line">// 语法
</span><span class="code-line">funcName.call(thisArg, arg1, arg2, ..) 
</span></code></pre>
<h4 id="143-apply"><a aria-hidden="true" tabindex="-1" href="#143-apply"><span class="icon icon-link"></span></a>1.4.3 apply</h4>
<p>通过apply方法可以调用它所属的函数(对象)。可以给函数提供运行时的this值，以及使用一个数组（或类似数组对象）作为参数。</p>
<pre><code class="code-highlight"><span class="code-line">// 语法
</span><span class="code-line">func.apply(thisArg, [argsArray])
</span></code></pre>
<h4 id="144-bind"><a aria-hidden="true" tabindex="-1" href="#144-bind"><span class="icon icon-link"></span></a>1.4.4 bind</h4>
<p>bind方法创建并返回一个新的函数，当这个绑定函数被调用时this值为其提供的值，其参数列表前几项值为创建绑定函数时指定的参数序列。</p>
<pre><code class="code-highlight"><span class="code-line">// 语法:
</span><span class="code-line">fun.bind(thisArg[, arg1[, arg2[, ...]]])
</span></code></pre>
<ul>
<li>thisArg：调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new运算符</code>构造绑定函数，则忽略该值。</li>
<li>arg1, arg2, ...：当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法</li>
</ul>
<h4 id="145-apply-vs-call-vs-bind-区别"><a aria-hidden="true" tabindex="-1" href="#145-apply-vs-call-vs-bind-区别"><span class="icon icon-link"></span></a>1.4.5 apply vs call vs bind 区别</h4>
<ul>
<li>
<p>apply和call都是函数对象的方法，两者都可以改变函数运行时的this，这个是apply和call的主要使用的功能。</p>
</li>
<li>
<p>apply和call不同在于，提供的参数格式不一样：apply需要的是一个参数数组；call需要的是参数列表。</p>
</li>
<li>
<p>bind与apply和call不同的是：apply和call是在每次调用的时候动态指定被调用函数的this和实参，apply和call自动帮我们对目标函数进行调用；而bind是创建一个新的封装绑定函数，这个绑定函数固定了目标函数的this值，和部分实参。</p>
</li>
</ul>
</div></div></div></div></div><div class="wrap h2body-exist"><div class="wrap-header h2wrap"><h2 id="二使用场景"><a aria-hidden="true" tabindex="-1" href="#二使用场景"><span class="icon icon-link"></span></a>[二]、使用场景</h2><div class="wrap-body">
</div></div><div class="h2wrap-body"><div class="wrap h3body-not-exist"><div class="wrap-header h3wrap"><h3 id="21-函数作为参数"><a aria-hidden="true" tabindex="-1" href="#21-函数作为参数"><span class="icon icon-link"></span></a>2.1 函数作为参数</h3><div class="wrap-body">
</div></div></div><div class="wrap h3body-not-exist"><div class="wrap-header h3wrap"><h3 id="22-函数作为返回值"><a aria-hidden="true" tabindex="-1" href="#22-函数作为返回值"><span class="icon icon-link"></span></a>2.2 函数作为返回值</h3><div class="wrap-body">
<p>函数作为返回值一个典型的情况就是闭包。比如之前提到的co.wrap使用了闭包。</p>
<pre><code class="code-highlight"><span class="code-line">co.wrap = function (fn) {
</span><span class="code-line">  createPromise.__generatorFunction__ = fn;
</span><span class="code-line">  return createPromise;
</span><span class="code-line">  function createPromise() {
</span><span class="code-line">    return co.call(this, fn.apply(this, arguments));
</span><span class="code-line">  }
</span><span class="code-line">};
</span></code></pre>
</div></div></div><div class="wrap h3body-not-exist"><div class="wrap-header h3wrap"><h3 id="23-立即执行表达式iife"><a aria-hidden="true" tabindex="-1" href="#23-立即执行表达式iife"><span class="icon icon-link"></span></a>2.3 立即执行表达式(IIFE)</h3><div class="wrap-body">
<p>简单来说：立即调用函数表达式，是一个在定义时就会立即执行的JS函数。</p>
<pre><code class="code-highlight"><span class="code-line">// 支持所有类型的函数
</span><span class="code-line">(function () {
</span><span class="code-line">  // body
</span><span class="code-line">})();
</span></code></pre>
<p><code>分析</code>：</p>
<ul>
<li>第一部分是包围在圆括号运算符<code>()</code> 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此<code>IIFE</code>中的变量，而且又不会污染全局作用域。</li>
<li>第二部分再一次使用<code>()</code>创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数</li>
</ul>
</div></div></div><div class="wrap h3body-not-exist"><div class="wrap-header h3wrap"><h3 id="24-函数原型链prototype"><a aria-hidden="true" tabindex="-1" href="#24-函数原型链prototype"><span class="icon icon-link"></span></a>2.4 函数原型链Prototype</h3><div class="wrap-body">
<p><a href="https://shimo.im/docs/sWPctYHDkToZaoIt/read">JS Prototype 原型&#x26;原型链</a></p>
</div></div></div><div class="wrap h3body-not-exist"><div class="wrap-header h3wrap"><h3 id="25-函数上下文"><a aria-hidden="true" tabindex="-1" href="#25-函数上下文"><span class="icon icon-link"></span></a>2.5 函数上下文</h3><div class="wrap-body">
<p><a href="https://shimo.im/docs/yzSqYk3YWd45YQgQ/read">JS Excuse Context</a></p>
</div></div></div><div class="wrap h3body-exist"><div class="wrap-header h3wrap"><h3 id="26-函数式编程"><a aria-hidden="true" tabindex="-1" href="#26-函数式编程"><span class="icon icon-link"></span></a>2.6 函数式编程</h3><div class="wrap-body">
<p>函数式编程是编程范式中的一种，是一种典型的编程思想和方法。其他的编程范式还包括面向<code>[对象编程]</code>，逻辑编程等。</p>
<p>编程范式的意义在于它提供了模块化代码的各种思想和方法。</p>
<ul>
<li>模块化使得开发更快、维护更容易</li>
<li>模块可以复用</li>
<li>模块化便于单元测试和debug</li>
</ul>
<p>由此可以理解为：函数式编程是以函数为核心来组织模块的一套编程方法。(不是写了函数就是函数式编程)</p>
<h4 id="261-高阶函数"><a aria-hidden="true" tabindex="-1" href="#261-高阶函数"><span class="icon icon-link"></span></a>2.6.1 高阶函数</h4>
<h4 id="262-纯函数"><a aria-hidden="true" tabindex="-1" href="#262-纯函数"><span class="icon icon-link"></span></a>2.6.2 纯函数</h4>
<p>符合以下要求的函数就是纯函数：</p>
<ul>
<li>相同输入总是会返回相同的输出。返回的结果只依赖于输入的参数且与外部系统状态无关。</li>
<li>没有副作用。不会影响该函数作用域以外的外部状态(比如全局变量、参数)。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>更加容易被测试，因为它们唯一的职责就是根据输入计算输出。</li>
<li>结果可以被缓存，因为相同的输入总会获得相同的输出。</li>
<li>自我文档化，因为函数的依赖关系很清晰。</li>
<li>更容易被调用，因为你不用担心函数会有什么副作用。</li>
</ul>
<h4 id="263-柯里化"><a aria-hidden="true" tabindex="-1" href="#263-柯里化"><span class="icon icon-link"></span></a>2.6.3 柯里化</h4>
<p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回一个新的函数的技术，新函数接受余下参数并返回运算结果。</p>
</div></div></div></div></div><div class="wrap h2body-not-exist"><div class="wrap-header h2wrap"><h2 id="拓展"><a aria-hidden="true" tabindex="-1" href="#拓展"><span class="icon icon-link"></span></a>拓展</h2><div class="wrap-body">
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/267403845"># JS Function 函数</a></li>
<li><a href="https://shimo.im/docs/MKnt1hIpFK4rp9ml/read">JS data type</a></li>
</ul>
</div></div><div class="h2wrap-body"></div></div><footer class="footer-wrap"><footer class="max-container">© 2022 Kenny Wang.</footer></footer><script src="../data.js" defer></script><script src="../js/fuse.min.js" defer></script><script src="../js/main.js" defer></script><div id="mysearch"><div class="mysearch-box"><div class="mysearch-input"><div><svg xmlns="http://www.w3.org/2000/svg" height="1em" width="1em" viewBox="0 0 18 18">
  <path fill="currentColor" d="M17.71,16.29 L14.31,12.9 C15.4069846,11.5024547 16.0022094,9.77665502 16,8 C16,3.581722 12.418278,0 8,0 C3.581722,0 0,3.581722 0,8 C0,12.418278 3.581722,16 8,16 C9.77665502,16.0022094 11.5024547,15.4069846 12.9,14.31 L16.29,17.71 C16.4777666,17.8993127 16.7333625,18.0057983 17,18.0057983 C17.2666375,18.0057983 17.5222334,17.8993127 17.71,17.71 C17.8993127,17.5222334 18.0057983,17.2666375 18.0057983,17 C18.0057983,16.7333625 17.8993127,16.4777666 17.71,16.29 Z M2,8 C2,4.6862915 4.6862915,2 8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 Z"></path>
</svg><input id="mysearch-input" type="search" placeholder="搜索" autocomplete="off"><div class="mysearch-clear"></div></div><button id="mysearch-close" type="button">搜索</button></div><div class="mysearch-result"><div id="mysearch-menu"></div><div id="mysearch-content"></div></div></div></div></body>
</html>
